controller:
  ## The name of the Ingress controller daemonset or deployment.
  ## Autogenerated if not set or set to "".
  # name: nginx-ingress

  ## The kind of the Ingress controller installation - deployment or daemonset.
  kind: deployment

  ## Deploys the Ingress controller for NGINX Plus.
  nginxplus: true

  # Timeout in milliseconds which the Ingress Controller will wait for a successful NGINX reload after a change or at the initial start.
  nginxReloadTimeout: 60000

  ## Support for App Protect
  appprotect:
    ## Enable the App Protect module in the Ingress Controller.
    enable: false

  ## Support for App Protect Dos
  appprotectdos:
    ## Enable the App Protect Dos module in the Ingress Controller.
    enable: false
    ## Enable debugging for App Protect Dos.
    debug: false
    ## Max number of nginx processes to support.
    maxWorkers: 0
    ## Max number of ADMD instances.
    maxDaemons: 0
    ## RAM memory size to consume in MB.
    memory: 0

  ## Enables the Ingress controller pods to use the host's network namespace.
  hostNetwork: false

  ## Enables debugging for NGINX. Uses the nginx-debug binary. Requires error-log-level: debug in the ConfigMap via `controller.config.entries`.
  nginxDebug: false

  ## The log level of the Ingress Controller.
  logLevel: 1

  ## A list of custom ports to expose on the NGINX ingress controller pod. Follows the conventional Kubernetes yaml syntax for container ports.
  customPorts: []

  image:
    ## The image repository of the Ingress controller.
    repository: nginx/nginx-ingress

    ## The tag of the Ingress controller image.
    tag: "2.1.1"

    ## The pull policy for the Ingress controller image.
    pullPolicy: IfNotPresent

  config:
    ## The name of the ConfigMap used by the Ingress controller.
    ## Autogenerated if not set or set to "".
    # name: nginx-config

    ## The annotations of the Ingress Controller configmap.
    annotations: {}

    ## The entries of the ConfigMap for customizing NGINX configuration.
    entries: {}

  ## It is recommended to use your own TLS certificates and keys
  defaultTLS:
    ## The base64-encoded TLS certificate for the default HTTPS server. If not specified, a pre-generated self-signed certificate is used.
    ## Note: It is recommended that you specify your own certificate.
    cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tDQpNSUlHUXpDQ0JTdWdBd0lCQWdJTUFUVmVwQmVLSWhCQ0ZrTzVNQTBHQ1NxR1NJYjNEUUVCQ3dVQU1Fd3hDekFKDQpCZ05WQkFZVEFrSkZNUmt3RndZRFZRUUtFeEJIYkc5aVlXeFRhV2R1SUc1MkxYTmhNU0l3SUFZRFZRUURFeGxCDQpiSEJvWVZOVFRDQkRRU0F0SUZOSVFUSTFOaUF0SUVjeU1CNFhEVEl4TURreE5EQTBNalF6TkZvWERUSXlNVEF4DQpOakEwTWpRek5Gb3dHekVaTUJjR0ExVUVBd3dRS2k1aVpXTmhiV1Y0TG1OdmJTNTJiakNDQVNJd0RRWUpLb1pJDQpodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU5DRmRmUGg0V2pCRlYrN0VhbUdMNUxiWUNpa1RjNXdFaFM2DQpFVENtM0dMem1GajRvaXJxQ2pEYUdJUjBsVHlGMVc3UDFyb2FIUEVmVi96ZGdwTkJQTitVbHJNTlZuaXc0eVBtDQpwc1NBUjlKSnRFMzQzZ0tEcytENDg3QUUveEZJN3lQbHRQY0pNWkViK05uc2dnTGFMZjAvS1lpK0JJT2JjOVZLDQpzS0dWUGpUUno0bHV2RVVmcEpvMHI1a2REQk5QajJoZzB6SjVCVUIxYWFnMGk1TmIyTGZhTVRaYWNyc3BpTmJ6DQpQVk54SVByNHI5TytnRVBDVTVMRVNRTnpXU1cvWVNrd1Y1RUptTnBTVUN6M0FHc1Q2MkhkMHkrVVB5a3JGUGczDQpJMElwSksyck9SVmg1UTVsVTRNZUl6dkxtME14NmMwcXVna1k5dmtlVDcyd1FZV1BGaUVDQXdFQUFhT0NBMVF3DQpnZ05RTUE0R0ExVWREd0VCL3dRRUF3SUZvRENCaVFZSUt3WUJCUVVIQVFFRWZUQjdNRUlHQ0NzR0FRVUZCekFDDQpoalpvZEhSd09pOHZjMlZqZFhKbE1pNWhiSEJvWVhOemJDNWpiMjB2WTJGalpYSjBMMmR6WVd4d2FHRnphR0V5DQpaekp5TVM1amNuUXdOUVlJS3dZQkJRVUhNQUdHS1doMGRIQTZMeTl2WTNOd01pNW5iRzlpWVd4emFXZHVMbU52DQpiUzluYzJGc2NHaGhjMmhoTW1jeU1GY0dBMVVkSUFSUU1FNHdRZ1lLS3dZQkJBR2dNZ0VLQ2pBME1ESUdDQ3NHDQpBUVVGQndJQkZpWm9kSFJ3Y3pvdkwzZDNkeTVuYkc5aVlXeHphV2R1TG1OdmJTOXlaWEJ2YzJsMGIzSjVMekFJDQpCZ1puZ1F3QkFnRXdDUVlEVlIwVEJBSXdBREErQmdOVkhSOEVOekExTURPZ01hQXZoaTFvZEhSd09pOHZZM0pzDQpNaTVoYkhCb1lYTnpiQzVqYjIwdlozTXZaM05oYkhCb1lYTm9ZVEpuTWk1amNtd3dLd1lEVlIwUkJDUXdJb0lRDQpLaTVpWldOaGJXVjRMbU52YlM1MmJvSU9ZbVZqWVcxbGVDNWpiMjB1ZG00d0hRWURWUjBsQkJZd0ZBWUlLd1lCDQpCUVVIQXdFR0NDc0dBUVVGQndNQ01COEdBMVVkSXdRWU1CYUFGUFhOMVR3SVVQbHFUenEzbDlwV2crWnAwbWozDQpNQjBHQTFVZERnUVdCQlRQOW8rV2loUCsvbmtHQ2tHN09ZNklGdGhmRlRDQ0FZQUdDaXNHQVFRQjFua0NCQUlFDQpnZ0Z3QklJQmJBRnFBSGNBYjFOMnJESHdNUm5ZbVFDa1VSWC9keFVjRWRrQ3dRQXBCbzJ5Q0pvMzJSTUFBQUY3DQo0b3l0eHdBQUJBTUFTREJHQWlFQTlhSjYzMXk3WVJFOFplUUptNDdVQXQ1SnRJSmNQendsUjlRNCthNmFOM3NDDQpJUURzTU80dVR5OXpSZ2JFSjVIdFd5b1MyT2cxc1g1ZzY0b3o5MWdyWlY4VTRBQjNBQ2w1dnZDZU9Ua2g4Rlp6DQpuMk9sZCtXK1YzMmNZQXI0K1UxZEpsd2xYY2VFQUFBQmUrS01ydDhBQUFRREFFZ3dSZ0loQU1Ldkc5ZkJVRk93DQpiVE1WbWtQQWVPVXNjR2RsNHg2dmdLdmhlSkFRUDQ4SkFpRUFyVVRoQ2o1Mk5oa2hWMVpRK3VPOEthYjdCVzd4DQo1NnRsRnRsQ05CelZHVkVBZGdCVmdkVENGcEEyQVVycUM1dFhQRlB3d09RNGVIQWxDQmN2bzZvZEJ4UFREQUFBDQpBWHZpaks3RUFBQUVBd0JITUVVQ0lRREJsUldMQU5KcWw5bWx3ZlhPZWttNzFwY0hOWGxXNmQvS0FmTGxpM1JaDQp0d0lnWUVYOUV6S2pWQ3hET3hIT09seDh5czZQR2VDeXgwMlBJUmdrVUpNZ1hyNHdEUVlKS29aSWh2Y05BUUVMDQpCUUFEZ2dFQkFNTzBQcWNERmYrOEVtZXRJbDJ3VzBNWTlHZkhscUE0VTBjSGJGRGpTMUpOTTI1UHB5dll3N1JNDQpJYUNkR0ZqOFlIN1hFVnllMGlDNXFIS2Y0T1Mzd21ZQ0RHenYvZlRDUWZzZ0xxejBEeTYyajNxMmJNWitSdHJnDQpFZWR6RjMyNHU3L1dxQXVvREwxVTRTbEFNMW54VkZMeEhRQlM4SHY0a0kxSUFvZnRwN1FXdzBrbmExdmZvNnRuDQpSWDJsL09kejVqQXZoS1dNSE5YR0dCc2ZHdnFObHdFTFJaUkp3c1JUZnBqNXE5K3lsemhyWVNtbzZ6ZFYwM1k1DQptMXN2a0lVRkZqeWhMYXhXSHRHL0E2T0NSTU1TTE1lTWU0aTJlVUlHMUhQOU5jdXk2ODNORmRYRmZteTNnVDV4DQpPZ0ROVnR5T3ZSczFrWDJVOEpmR2dGb2srQmhnWjRRPQ0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ== 

    ## The base64-encoded TLS key for the default HTTPS server. Note: If not specified, a pre-generated key is used.
    ## Note: It is recommended that you specify your own key.
    key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tDQpNSUlFdWdJQkFEQU5CZ2txaGtpRzl3MEJBUUVGQUFTQ0JLUXdnZ1NnQWdFQUFvSUJBUURRaFhYejRlRm93UlZmDQp1eEdwaGkrUzIyQW9wRTNPY0JJVXVoRXdwdHhpODVoWStLSXE2Z293MmhpRWRKVThoZFZ1ejlhNkdoenhIMWY4DQozWUtUUVR6ZmxKYXpEVlo0c09NajVxYkVnRWZTU2JSTitONENnN1BnK1BPd0JQOFJTTzhqNWJUM0NUR1JHL2paDQo3SUlDMmkzOVB5bUl2Z1NEbTNQVlNyQ2hsVDQwMGMrSmJyeEZINlNhTksrWkhRd1RUNDlvWU5NeWVRVkFkV21vDQpOSXVUVzlpMzJqRTJXbks3S1lqVzh6MVRjU0Q2K0svVHZvQkR3bE9TeEVrRGMxa2x2MkVwTUZlUkNaamFVbEFzDQo5d0JyRSt0aDNkTXZsRDhwS3hUNE55TkNLU1N0cXprVlllVU9aVk9ESGlNN3k1dERNZW5OS3JvSkdQYjVIays5DQpzRUdGanhZaEFnTUJBQUVDZ2Y5VTJhSXMrbnQ4NHhUbGFudW9LQ1Zmamt1RUVsQmpzSWRUT0VabldkYU9wK0Z6DQpvMFBXVDlyNlR5UWY1b1BwbVN6M1NZenlTdEtEYU0vK21QL1pxaEZWdGloTDlhVWM4OGUwUWQzanNZS3N6WHozDQpmMVNyM1NaTnhIeEFPZVdDT1FiY0NhUXNCbnUra0g3QlUwR0ZqOVRQS2FLMXVNaVNlLyt0MG9yYUxpblJmNTl2DQpuNm1jb0YybzVUQkw4S1NBUTE0NE80N0VvVWp4VEc1S2pqWXEzOExXVVI3TWNudWtwbDZYZnlkOU14NUFGTkZpDQpwdElnVDR0ZFBLT0tjL2RmY3g0cC9hRGpqQ1RpTEdPMU5FeitTdnJUOElUbkdjSmZZeDJ1R1RDYUkwOEoxZHlJDQpzZ2xCN2tWS0g2K0s5cGsybmVZcjFGenptdm42WVZ5U0JBSVpENEVDZ1lFQTd5ZVVwcCtDaWtkQWNaeVZ3VEVFDQp6YXdXck91bnBVKzRDOCs1cHNENGczMThXNVU0REhPZldaa0FpUjlpeGI5ZE9TeENIR2c2L1BPU005K05GcHRSDQp1Q2hYKytwdkVUZXdTQVl4OUc4a0tsRCtzU0xIaUNaRUw3cngrK2ZNbXZCN1RFczVXM0NiTEFOSHVFOFNuV3FoDQovUEY1TlRZa2tSVnRZTmZRZGVxT2Zia0NnWUVBM3pXQXZhYmVtTmt4ZlhyTzJYVXpXS0hqTTR1V1o3czFBWndQDQpOcjEyNHpWQ2pqZ0lwQ0JpallIU203dlNsaWp1ZjlRdWdmYW91aVE2RkZvNjRxS2M1dVgzbnlRMGtZZVh2ZUJLDQpTckRrdWZWVjJyL0w3anJzZ1hERm5TSzRDUVpZMHlxcS80MEZCNUtITlBvblRTeklCOW1OUFVDUTN2cWQ2Y0RKDQpjeU5DVDZrQ2dZQk9Laldmc0FyT2Z6TkU3dFRUYTk0U0N1anVZNmRMbEo2bTNhSGtLcllPNC9pOVJpd25oYkxUDQphZnFPMXI5RnVxSVJpYkdoN3o4NFpiT25XSzJZY2ZObnFXZjRZa3NpNlh5b1RiNE9FalZUejEwdk1CcmZHUUs0DQpSdlhJUzU3SUZVbDNTaTdaQUJqM2Jhc0hSbkRqR25NUFpTMGtneW00Y2JScUxwOW5xdDRmb1FLQmdFTWdOdmhSDQovNjFkMi9sTmZubDlPcFRVRXB6RXhOV3JRaFNhMXlSeU5CZStRNmE3aVRXNm00ak0yd2FFcEo4TjdqTzVIc2RzDQo0MjhmUit3bytuNS93c25ack85S0Z4a1ErdnhhUUYxWDkyRkpPNm1PZG9qTlphVER3bG93UDhKUEMxVnVCb0RWDQo2d1pNOWFaaitIL0lFTnZ6ZS90SXVJaW1PK2s1Vmh2dkpaa0pBb0dBTzl0WWhxcUJrQ1JobVBUdGg2S0d3Z1VBDQpnR3pCSmhYNTVmbGY3a3lHL21Tc2VwcnFsWm1xOEpFNVpuYTBEd1lyS1RYSDBTZndjMloraWUwQ2pKem4rdHNpDQpGQUV6Q3BOeWlYaHkyZW5HLzdjbFA4cVRQazNuVlpnRWUxV05uZWQ5WTJ1YjhLWHBzM2JpTVJmR2VpRUFnc0RuDQpJNGhSNE50UWlIZE5IWjhiRW53PQ0KLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQ0K 

    ## The secret with a TLS certificate and key for the default HTTPS server.
    ## The value must follow the following format: `<namespace>/<name>`.
    ## Used as an alternative to specifying a certificate and key using `controller.defaultTLS.cert` and `controller.defaultTLS.key` parameters.
    ## Format: <namespace>/<secret_name>
    secret: "kubeapps/becamexidc-cert"

  wildcardTLS:
    ## The base64-encoded TLS certificate for every Ingress/VirtualServer host that has TLS enabled but no secret specified.
    ## If the parameter is not set, for such Ingress/VirtualServer hosts NGINX will break any attempt to establish a TLS connection.
    cert: ""

    ## The base64-encoded TLS key for every Ingress/VirtualServer host that has TLS enabled but no secret specified.
    ## If the parameter is not set, for such Ingress/VirtualServer hosts NGINX will break any attempt to establish a TLS connection.
    key: ""

    ## The secret with a TLS certificate and key for every Ingress/VirtualServer host that has TLS enabled but no secret specified.
    ## The value must follow the following format: `<namespace>/<name>`.
    ## Used as an alternative to specifying a certificate and key using `controller.wildcardTLS.cert` and `controller.wildcardTLS.key` parameters.
    ## Format: <namespace>/<secret_name>
    secret: "kubeapps/becamexidc-cert"

  ## The node selector for pod assignment for the Ingress controller pods.
  nodeSelector: {}

  ## The termination grace period of the Ingress controller pod.
  terminationGracePeriodSeconds: 30

  ## The resources of the Ingress controller pods.
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 64Mi
    # requests:
    #   cpu: 100m
    #   memory: 64Mi

  ## The tolerations of the Ingress controller pods.
  tolerations: []

  ## The affinity of the Ingress controller pods.
  affinity: {}

  ## The volumes of the Ingress controller pods.
  volumes: []
  # - name: extra-conf
  #   configMap:
  #     name: extra-conf

  ## The volumeMounts of the Ingress controller pods.
  volumeMounts: []
  # - name: extra-conf
  #   mountPath: /etc/nginx/conf.d/extra.conf
  #   subPath: extra.conf

  ## InitContainers for the Ingress controller pods.
  initContainers: []
  # - name: init-container
  #   image: busybox:1.34
  #   command: ['sh', '-c', 'echo this is initial setup!']

  ## The number of replicas of the Ingress controller deployment.
  replicaCount: 1

  ## A class of the Ingress controller.

  ## IngressClass resource with the name equal to the class must be deployed. Otherwise,
  ## the Ingress Controller will fail to start.
  ## The Ingress controller only processes resources that belong to its class - i.e. have the "ingressClassName" field resource equal to the class.

  ## The Ingress Controller processes all the resources that do not have the "ingressClassName" field for all versions of kubernetes.
  ingressClass: nginx

  ## New Ingresses without an ingressClassName field specified will be assigned the class specified in `controller.ingressClass`.
  setAsDefaultIngress: true

  ## Namespace to watch for Ingress resources. By default the Ingress controller watches all namespaces.
  watchNamespace: ""

  ## Enable the custom resources.
  enableCustomResources: true

  ## Enable preview policies.
  enablePreviewPolicies: false

  ## Enable TLS Passthrough on port 443. Requires controller.enableCustomResources.
  enableTLSPassthrough: true

  globalConfiguration:
    ## Creates the GlobalConfiguration custom resource. Requires controller.enableCustomResources.
    create: false

    ## The spec of the GlobalConfiguration for defining the global configuration parameters of the Ingress Controller.
    spec: {}
      # listeners:
      # - name: dns-udp
      #   port: 5353
      #   protocol: UDP
      # - name: dns-tcp
      #   port: 5353
      #   protocol: TCP

  ## Enable custom NGINX configuration snippets in Ingress, VirtualServer, VirtualServerRoute and TransportServer resources.
  enableSnippets: false

  ## Add a location based on the value of health-status-uri to the default server. The location responds with the 200 status code for any request.
  ## Useful for external health-checking of the Ingress controller.
  healthStatus: true

  ## Sets the URI of health status location in the default server. Requires controller.healthStatus.
  healthStatusURI: "/nginx-health"

  nginxStatus:
    ## Enable the NGINX stub_status, or the NGINX Plus API.
    enable: true

    ## Set the port where the NGINX stub_status or the NGINX Plus API is exposed.
    port: 8080

    ## Add IPv4 IP/CIDR blocks to the allow list for NGINX stub_status or the NGINX Plus API. Separate multiple IP/CIDR by commas.
    allowCidrs: "127.0.0.1"

  service:
    ## Creates a service to expose the Ingress controller pods.
    create: true

    ## The type of service to create for the Ingress controller.
    type: LoadBalancer

    ## The externalTrafficPolicy of the service. The value Local preserves the client source IP.
    externalTrafficPolicy: Local

    ## The annotations of the Ingress controller service.
    annotations: {}

    ## The extra labels of the service.
    extraLabels: {}

    ## The static IP address for the load balancer. Requires controller.service.type set to LoadBalancer. The cloud provider must support this feature.
    loadBalancerIP: "192.168.103.180"

    ## The list of external IPs for the Ingress controller service.
    externalIPs: [192.168.103.180, 192.168.103.184]

    ## The IP ranges (CIDR) that are allowed to access the load balancer. Requires controller.service.type set to LoadBalancer. The cloud provider must support this feature.
    loadBalancerSourceRanges: []

    ## The name of the service
    ## Autogenerated if not set or set to "".
    # name: nginx-ingress

    httpPort:
      ## Enables the HTTP port for the Ingress controller service.
      enable: true

      ## The HTTP port of the Ingress controller service.
      port: 80

      ## The custom NodePort for the HTTP port. Requires controller.service.type set to NodePort.
      nodePort: ""

      ## The HTTP port on the POD where the Ingress controller service is running.
      targetPort: 80

    httpsPort:
      ## Enables the HTTPS port for the Ingress controller service.
      enable: true

      ## The HTTPS port of the Ingress controller service.
      port: 443

      ## The custom NodePort for the HTTPS port. Requires controller.service.type set to NodePort.
      nodePort: ""

      ## The HTTPS port on the POD where the Ingress controller service is running.
      targetPort: 443

    ## A list of custom ports to expose through the Ingress controller service. Follows the conventional Kubernetes yaml syntax for service ports.
    customPorts: []

  serviceAccount:
    ## The name of the service account of the Ingress controller pods. Used for RBAC.
    ## Autogenerated if not set or set to "".
    # name: nginx-ingress

    ## The name of the secret containing docker registry credentials.
    ## Secret must exist in the same namespace as the helm release.
    imagePullSecretName: ""

  reportIngressStatus:
    ## Updates the address field in the status of Ingress resources with an external address of the Ingress controller.
    ## You must also specify the source of the external address either through an external service via controller.reportIngressStatus.externalService,
    ## controller.reportIngressStatus.ingressLink or the external-status-address entry in the ConfigMap via controller.config.entries.
    ## Note: controller.config.entries.external-status-address takes precedence over the others.
    enable: true

    ## Specifies the name of the service with the type LoadBalancer through which the Ingress controller is exposed externally.
    ## The external address of the service is used when reporting the status of Ingress, VirtualServer and VirtualServerRoute resources.
    ## controller.reportIngressStatus.enable must be set to true.
    ## The default is autogenerated and matches the created service (see controller.service.create).
    # externalService: nginx-ingress

    ## Specifies the name of the IngressLink resource, which exposes the Ingress Controller pods via a BIG-IP system.
    ## The IP of the BIG-IP system is used when reporting the status of Ingress, VirtualServer and VirtualServerRoute resources.
    ## controller.reportIngressStatus.enable must be set to true.
    ingressLink: ""

    ## Enable Leader election to avoid multiple replicas of the controller reporting the status of Ingress resources. controller.reportIngressStatus.enable must be set to true.
    enableLeaderElection: true

    ## Specifies the name of the ConfigMap, within the same namespace as the controller, used as the lock for leader election. controller.reportIngressStatus.enableLeaderElection must be set to true.
    ## Autogenerated if not set or set to "".
    # leaderElectionLockName: "nginx-ingress-leader-election"

    ## The annotations of the leader election configmap.
    annotations: {}

  pod:
    ## The annotations of the Ingress Controller pod.
    annotations: {}

    ## The additional extra labels of the Ingress Controller pod.
    extraLabels: {}

  ## The PriorityClass of the ingress controller pods.
  priorityClassName:

  readyStatus:
    ## Enables readiness endpoint "/nginx-ready". The endpoint returns a success code when NGINX has loaded all the config after startup.
    enable: true

    ## Set the port where the readiness endpoint is exposed.
    port: 8081

  ## Enable collection of latency metrics for upstreams. Requires prometheus.create.
  enableLatencyMetrics: false

rbac:
  ## Configures RBAC.
  create: true

prometheus:
  ## Expose NGINX or NGINX Plus metrics in the Prometheus format.
  create: true

  ## Configures the port to scrape the metrics.
  port: 9113

  ## Specifies the namespace/name of a Kubernetes TLS Secret which will be used to protect the Prometheus endpoint.
  secret: ""

  ## Configures the HTTP scheme used.
  scheme: http

